```ts
import fs from 'fs'
import path from 'path'
import matter from 'gray-matter'
import { remark } from 'remark'
import html from 'remark-html'
import remarkPrism from "remark-prism";
import slugify from 'slug'
// const postsDirectory = path.join(process.cwd(), 'blog')




export function getAllPostIds() {

    const Directory = path.join(process.cwd(), 'blog')
    const subdirectories = fs.readdirSync(Directory, { withFileTypes: true })
      .filter(dirent => dirent.isDirectory())
      .map(dirent => dirent.name)
  
    const paths = subdirectories.flatMap(subdirectory => {
      const directoryPath = path.join(Directory, subdirectory)
      const filenames = fs.readdirSync(directoryPath)
        .filter(filename => filename.endsWith('.md'))

        // return filenames.map(filename => {
        //   const slug = [subdirectory, filename.replace(/\.md$/, '')];
        //   const slugPath = slug.join('/');
        //   const formattedSlug = slugify(slugPath, { lower: true, replacement: '/', remove: null });
        //   return {
        //     params: {
        //       slug: formattedSlug + '.html'
        //     }
        //   }
        // })  
  
      return filenames.map(filename => ({
        params: {
          slug: [subdirectory, filename.replace(/\.md$/, '').concat('.html')]
        }
      }))

    })
    console.log(paths)
    return paths
}

// export function getSortedPostsData() {

//     const Directory = path.join(process.cwd(), 'blog')
//     const subdirectories = fs.readdirSync(Directory, { withFileTypes: true })
//       .filter(dirent => dirent.isDirectory())
//       .map(dirent => dirent.name)
  
//     const posts = subdirectories.flatMap(subdirectory => {
//       const directoryPath = path.join(Directory, subdirectory)
//       const filenames = fs.readdirSync(directoryPath)
//         .filter(filename => filename.endsWith('.md'))

//         const allPostsData = filenames.map(filename => {
//             // Remove ".md" from file name to get id
//             const slug = [subdirectory, filename.replace(/\.md$/, '').concat('.html')]
        
//             // Read markdown file as string
//             const fullPath = path.join(postsDirectory, [subdirectory, filename].join("\\"))
//             const fileContents = fs.readFileSync(fullPath, 'utf8')
        
//             // Use gray-matter to parse the post metadata section
//             const matterResult = matter(fileContents)
        
//             // Combine the data with the id
//             return {
//               slug,
//               ...(matterResult.data as { date: string; title: string })
//             }
//           })
//           return allPostsData.sort((a, b) => {
//             if (a.date < b.date) {
//               return 1
//             } else {
//               return -1
//             }
//           })
//     })
  
//   // Sort posts by date
//   return posts

// }

export function getSortedPostsData() {

  const path = require('path');

    const Directory = path.join(process.cwd(), 'blog')
    const subdirectories = fs.readdirSync(Directory, { withFileTypes: true })
      .filter(dirent => dirent.isDirectory())
      .map(dirent => dirent.name)
  
    const posts = subdirectories.flatMap(subdirectory => {
      const directoryPath = path.join(Directory, subdirectory)
      const filenames = fs.readdirSync(directoryPath)
        .filter(filename => filename.endsWith('.md'))

        const allPostsData = filenames.map(filename => {
            // Remove ".md" from file name to get id
            const slug = [subdirectory, filename.replace(/\.md$/, '').concat('.html')].join("/")
        
            // Read markdown file as string
            const fullPath = path.join(Directory, [subdirectory, filename].join("//"))
            const fileContents = fs.readFileSync(fullPath, 'utf8')

              // 统计中文字符数
            const chineseCount = fileContents.match(/[\u4e00-\u9fa5]/g).length;

            // 统计英文单词数
            const englishCount = fileContents.match(/[a-zA-Z]+/g).length;

            const wordCount = chineseCount + englishCount
        
            // Use gray-matter to parse the post metadata section
            const matterResult = matter(fileContents)
        
            // Combine the data with the id
            return {
              slug,
              wordCount,
              ...(matterResult.data as { date: string; title: string })
            }
          })
          return allPostsData.sort((a, b) => {
            if (a.date < b.date) {
              return 1
            } else {
              return -1
            }
          })
    })
  
  // Sort posts by date
  return posts

}


export async function getPostData(slug:any) {

  const path = require('path');
  const aPath = path.join(process.cwd(), 'blog')
  const idjoin = slug.toString().split(",").join("//").replace(/\.html$/, '')
  const id = path.join(idjoin);
  const fullPath = path.join(aPath, `${id}.md`)
  const fileContents = fs.readFileSync(fullPath, 'utf8')
  const chineseChars = fileContents.match(/[\u4e00-\u9fa5]/g);

  // 统计中文字符数
  const chineseCount = fileContents.match(/[\u4e00-\u9fa5]/g).length;

  // 统计英文单词数
  const englishCount = fileContents.match(/[a-zA-Z]+/g).length;

  const wordCount = chineseCount + englishCount
  console.log(`文章字数为：${wordCount}`);
  console.log(`中文字符个数：${chineseCount}`);
  console.log(`英文单词个数：${englishCount}`);
  console.log(`中英文字符总数：${chineseCount + englishCount}`);

  // Use gray-matter to parse the post metadata section
  const matterResult = matter(fileContents)

  const date = new Date(matterResult.data.date).toISOString()

  // Use remark to convert markdown into HTML string
  const processedContent = await remark()
    .use(html, { sanitize: false })
    .use(remarkPrism, { plugins: ["line-numbers"] })
    .process(matterResult.content)
  const contentHtml = processedContent.toString()
  
  const baseUrl = 'https://fanmau.github.io';
  const imgRegex = /<img.*?src="(.*?)"/g;
  let match: any[];
  while ((match = imgRegex.exec(contentHtml)) !== null) {
    const imgPath = match[1];
    const imgUrl = `${baseUrl}${imgPath}`;
    console.log(imgUrl);
  }

  // const imgRegex = /<img.*?src="(.*?)"/g;

  // // 获取所有图片链接
  // const imgLinks = [];
  // let match: any[];
  // while ((match = imgRegex.exec(contentHtml)) !== null) {
  //   imgLinks.push(match[1]);
  // }

  // // 输出所有图片链接
  // console.log(imgLinks);

  // const mtime = fs.stat(fullPath, (err, stats) => {
  //   if (err) throw err;
  //   console.log(`Last modified: ${stats.mtime}`);
  // });
  
//   const filePath = fullPath;

// try {
//   const stats = fs.statSync(filePath);
//   const lastModified = stats.mtime;
//   console.log(`The file was last modified on ${lastModified}`);
// } catch (err) {
//   console.error(err);
// }

//   const mtime = lastModified

  const filePath = fullPath;
  const fileStat = fs.statSync(filePath);
  const mtime = fileStat.mtime.toISOString();
  const birthtime = fileStat.birthtime.toISOString();

  // const amtime = moment.tz(fileStat.mtime, 'Asia/Shanghai').format('YYYY-MM-DDTHH:mm:ss.sssZ');
  // const actime = moment.tz(fileStat.birthtime, 'Asia/Shanghai').format('YYYY-MM-DDTHH:mm:ssZ');
  
  console.log(birthtime);
  // console.log(`Modified Time: ${amtime}`);
  // console.log(`Created Time: ${actime}`);
  // Combine the data with the id and contentHtml
  return {
    birthtime,
    mtime,
    slug,
    wordCount,
    contentHtml,
    ...(matterResult.data as { date: string; title: string; })
  }
}

const contentDirectory = 'blog'; // 替换成你的文章目录

export const calculateWordCount = (): number => {

let totalWordCount = 0;

// 遍历文章目录下所有的 .md 文件
const readDirectory = (dir: string) => {
  fs.readdirSync(dir).forEach(item => {
    // 忽略文件名以 "." 开头的文件或文件夹
    if (item[0] === '.')
      return;
    const itemPath = path.join(dir, item);
    const stats = fs.statSync(itemPath);

    if(stats.isFile() && itemPath.endsWith('.md')) { // 如果是 .md 文件
      const fileContents = fs.readFileSync(itemPath, 'utf8');

      // 统计中文字符数
      const chineseCount = fileContents.match(/[\u4e00-\u9fa5]/g)?.length || 0;

      // 统计英文单词数
      const englishCount = fileContents.match(/[a-zA-Z]+/g)?.length || 0;

      totalWordCount += chineseCount + englishCount;
    } else if(stats.isDirectory()) { // 如果是文件夹
      readDirectory(itemPath);
    }
  });
}

readDirectory(contentDirectory);


  return totalWordCount;
};
console.log(`全站总字数为：${calculateWordCount()}`);

上面是 /lib/blog.ts 里的代码

下是 [...slug].tsx 里的代码

import Layout, { name, siteTitle, desc, baseURL, author, authorurl } from '@/components/layout'
import { getAllPostIds, getPostData } from '../../lib/blog'
import Head from 'next/head'
import { GetStaticProps, GetStaticPaths } from 'next'
import Date from '../../components/date'
import { useRouter } from 'next/router'
import slugify from 'slug'

export default function Post({
  postData
}: {
  postData: {
    slug: string
    title: string
    date: string
    birthtime: string
    mtime: string
    wordCount: string
    contentHtml: string
  }
}) {

    const namea = postData.title;
    const nameb = " | "
    const namec = name;
    const title = namea.concat(nameb,namec);
    const router = useRouter();

    function addProductJsonLd() {
      return {
        __html: `{
          "@context": "http://schema.org",
          "@type": "Article",
          "name": "${name}",
          "headline": "${postData.title}",
          "author": {
            "@type": "Person",
            "name": "${author}",
            "url": "${authorurl}"
          },
          "datePublished": "${postData.birthtime}",
          "image": "",
          "articleSection": "",
          "url": "https://fanmav.github.io${router.asPath}"
        }
    `,
      };
    }

  return (
    <Layout>
      <Head>
        <title>{title}</title>
        <meta name="keywords" content="FanMa,博客,Next.js" />
        {/* <meta name="description" content={desc} /> */}
        <meta property="og:type" content="website" />
        <meta property="og:site_name" content={name} />
        <meta property="og:title" content={siteTitle} />
        <meta property="og:locale" content="zh-CN" />
        <meta property="og:url" content={baseURL} />
        <meta property="og:image" content="https://fanmav.github.io/images/fanma.jpg" />
        {/* <meta property="og:updated_time" content={date} /> */}
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <script
          type="application/ld+json"
          dangerouslySetInnerHTML={addProductJsonLd()}
          key="product-jsonld"
        />
      </Head>
      <article>
        <h1 className='title'>{postData.title}<div className='title-date'><small><Date dateString={postData.date} /> - <span>约 {postData.wordCount} 字</span></small></div></h1>
        {/* <div>{postData.mtime}</div>
        <div>{postData.ctime}</div> */}
        <div>{postData.slug}</div>
        <div dangerouslySetInnerHTML={{ __html: postData.contentHtml }} />
      </article>
    </Layout>
  )
}

export const getStaticPaths: GetStaticPaths = async () => {
  const paths = getAllPostIds()
  
  // console.log(`文章路径：${JSON.stringify(paths)}`)
  // console.log(`文章路径：${paths}`)
  return {
    paths,
    fallback: false
  }
}

export const getStaticProps: GetStaticProps = async ({ params }) => {
  const originalSlug = params?.slug?.toString().split(",").join("/")
  const slug = originalSlug.replace(/\.html$/, '')
  // const slug = originalSlug.endsWith(".html") ? originalSlug.replace(/\.html$/, '') : originalSlug
  // 将 .html 扩展名删除
  const postData = await getPostData(slug as string)
  // const postData = await getPostData(params?.slug as string)
  return {
    props: {
      postData
    }
  }
}

// console.log(`文章路径：${JSON.stringify(paths)}`)

export const Comment = () => {
  const router = useRouter()
  const slug = (router.query.slug as string[]) || []
  const di = slug.join('/')

  return ({
    dir: {di},
  })
}

我如何实现 url 为 /blog/2023/1.html ，生成静态页路径为 /blog/2023/1.html 。我现在的代码 生成静态页路径为 /blog/2023/1.html.html，HTML静态文件后面多了一个 .html
```
# Next.js 13 [...slug].tsx 可以指定一个参数来作为生成静态文件的文件名吗

```ts
import fs from 'fs/promises';
import path from 'path';
import Layout from '../../../components/Layout';

export default function Post(props) {
  const { title, content } = props;

  return (
    <Layout>
      <h1>{title}</h1>
      <div dangerouslySetInnerHTML={{ __html: content }}></div>
    </Layout>
  )
}

export async function getStaticProps({ params }) {
  const slug = params.slug.join('/');
  const postPath = path.join(process.cwd(), 'posts', `${slug}.md`);
  const fileContent = await fs.readFile(postPath, 'utf8');
  return {
    props: {
      title: `Post: ${slug}`,
      content: fileContent
    },
    // 将动态参数用于生成静态文件名
    // 如果动态路径是 /posts/2021/09/example
    // 则静态文件名为 2021-09-example.html
    // 注意：文件名必须以 .html 结尾
    // 如果想要去掉 .html 后缀，可以在 next.config.js 中设置 exportTrailingSlash 为 true
    // 或在 exportPathMap 中设置页面路径及名称
    // 更多细节请参见官方文档：https://nextjs.org/docs/api-reference/next.config.js/exportPathMap
    //
    // 在生产模式下，需要注意的是指定的静态文件名不应包含字符，如口号、空格等
    // 它通常只包含字母、数字、下划线或短划线
    // 我们在下面示例代码中使用短划线
    //  
    // 如果你想要自动处理静态文件名，而不必手动创建映射表，可以设置 fallback: 'blocking'
    // 这将在运行时自动构建一个静态文件映射表，并在需要时加载相关页面。
    // 但注意：fallback: 'blocking' 选项可能会影响启动时间和效率，因为它需要构建一个映射表
    // 
    // 默认值为 fallback: true，若你不期望自动生成静态文件，而是期待 404 配置，可以将 fallback: false
    fallback: false
  };
}

export async function getStaticPaths() {
  const postsDirectory = path.join(process.cwd(), 'posts');
  const filenames = await fs.readdir(postsDirectory);

  const paths = filenames.map((filename) => {
    const filePath = path.join(postsDirectory, filename);
    const slug = filename.slice(0, -3);
    return {
      params: {
        slug: slug.split('-')
      }
    }
  })

  return {
    paths,
    fallback: false
  }
}
```