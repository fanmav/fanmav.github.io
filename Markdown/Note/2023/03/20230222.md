

## 如何使用 Next.js 构建高效的博客网站


在创建博客网站前，您先要安装好 `Next.js` 等相关依赖才能进行下去。在这里我们并不使用 `Next.js` 官方的方法来安装 `Next.js` 框架。这是由于我们在写博客程序的时候需要安装相关功能的一些依赖，如果功能使用得多的话，安装的依赖也就越多。

为了避免每使用一个功能就要安装一次依赖，在这我们把这一步全部在这里给它做后，后面就不再需要一步一步安装相关的依赖了。

### 系统要求

新版本的 Next.js 对系统还是有一定的要求的，它必需满足以下条件才可以正常稳定的运行。

- Node.js 版本至少为 14.6.0 建议 16.0.0 以上版本。
- MacOS, Windows (including WSL), and Linux are supported，（ 至少为 Windows 10 系统，Windows 7 支持并不友好，Windows 7 已经安装不了 Node.js 12.2.0 版本了。）


### 创建目录

我们在D盘创建一个名为 `Next-Blog` 的目录，路径为 `D:\Next-Blog` 。当然也中以根据你的实际情况，创建自己喜欢的目录名称，位置也是可以随意调整的。

### 创建 JSON

我们使用 `VS Code` 来编写 Next.js 代码，它用来编写代码非常地方便，可以自动补全、自动导入、移动文件会自动更新引用路径等等非常方便且实用的功能。

先打开 `VS Code` 软件，然后点击 `打开文件夹` ，找到并选择刚才创建的 `Next-Blog` 文件夹，这个文件夹就是我们的项目根目录了。

使用 `VS Code` 在 `Next-Blog` 根目录创建一个名为 `package.json` 的文件。在里面写入下面的代码内容：

```json
{
    "name": "next-blog",
    "private": true,
    "scripts": {
        "build": "next build",
        "dev": "next dev",
        "start": "next start",
        "export": "next export"
    },
    "dependencies": {
        "date-fns": "^2.29.3",
        "gray-matter": "^4.0.3",
        "next": "latest",
        "react": "18.2.0",
        "react-dom": "18.2.0",
        "remark": "^14.0.2",
        "remark-html": "^15.0.1"
    }
}
```

在 `package.json` 文件里的 `name` 为项目名称，注意： `name` 的名称是不可以使用大写的，这个必需要遵守。在 `scripts` 里的内容为一些 npm 的一些启动相关的命令：

- build ：打包生成静态文件。
- dev ：启动开发服务器。
- start ：启动生产环境。
- export ：把打包生成的静态文件输出到名为 `out` 的目录里。

里面的 `dependencies` 是我们所需要的相关依赖，它包含了 `next` `react` `react-dom` 主要内容，其他都是我们后面需要使用的相关依赖。

### 安装 Next.js

把上面的全部设置好后，在 `VS Code` 软件里按组合键 Ctrl Shift + ` 打开终端命令窗口。

在终端命令窗口输入 `npm install` 并回车。

```ssh
npm install
```

使用这个命令会把 `package.json` 里的所有依赖都帮你安装上去，就不用每次使用的时候再安装一篇了。安装的时候可能需要花费一定的时间，请稍等一下就好了。

上面的命令运行完成后，我们的博客项目就已经初始化完成了。





## 博客首页

### 启动服务

我们的博客项目创建完成后，先启动一下服务看一下能不能正常运行。在 `VS Code` 终端命令窗口输入 `npm run dev` 启动开发服务器。

```ssh
npm run dev
```

我们启动开发服务器的时候它会报错，因为我们并没有添加任何东西进去，所以它才会这样子。丢点击一下 `VS Code` 终端命令窗口，按下组合键 `Ctrl + C` 退出开发服务器。

接下来，我们要做的就是，在项目根目录 `Next-Blog` 创建一个名为 `pages` 的文件夹，然后在终端命令窗口输入 `npm run dev` 启动开发服务器。

这时候，在浏览器地址栏输入 `http://localhost:3000` 并回车，这时它会显示一个 404 页面。

```404
404 | This page could not be found.
```

### 创建首页

在 pages 文件夹里创建一个 `index.js` 文件，在这个文件里写入下面的代码。

```js
export default function Home() {
  return (
    <main>
        <h1>
            FanMa Blog's HomePage
        </h1>
        <p>
            This a FanMa Blog.
        </p>
    </main>
  );
}
```
把上面的代码输入到 `index.js` 文件里后，按下组合键 Ctrl + S 保存刚才输入的代码内容。

然后我们再回到浏览器，刷新一下 http://localhost:3000 页面（它也可能会自动帮你刷新页面），现在我们就可以看到这个网页显示 `FanMa Blog's HomePage` 和 `This a FanMa Blog.` 的内容。


### 首篇文章

在 pages 文件夹里创建一个 `posts` 文件夹，并在 `posts` 文件夹里创建一个 `first-post.js`  文件，最后在文件里写入下面的代码。

```js
export default function FirstPost() {
    return <h1>FanMa's First Post</h1>;
}
```

在浏览器里访问 `http://localhost:3000/posts/first-post` 网页，这时你应该可以看到网页里显示 `FanMa's First Post` 的信息内容。

回到 `pages/index.js` 内容里，在内容顶部添加下面的代码用来引入 `Link` 组件 `next/link` 。

```ts
import Link from 'next/link';
```

然后在下面找到 `<main>` 标签，在这个标签里面添加下面的代码内容进去。

```js
<ul>
    <li>
        <Link href="/posts/first-post">My first post.</Link>
    </li>
</ul>
```

此时 `pages/index.js` 完整的内容如下所示：

```js
import Link from 'next/link';

export default function Home() {
  return (
    <main>
        <h1>
            FanMa Blog's HomePage
        </h1>
        <p>
            This a FanMa Blog.
        </p>
        <ul>
            <li>
                <Link href="/posts/first-post">My first post.</Link>
            </li>
        </ul>
    </main>
  );
}
```

按照上面的方法，接下来打开 `pages/posts/first-post.js` 并将其内容替换为以下内容：

```js
import Link from 'next/link';

export default function FirstPost() {
    return (
        <>
            <h1>FanMa's First Post</h1>
            <h2>
                <Link href="/">Back to home</Link>
            </h2>
        </>
    );
}
```

回到 `pages/index.js` 文件里里，在文件顶部添加下面的代码用来引入 `Head` 组件 `next/head` 。

```js
import Head from 'next/head';
```

然后在 `<main>` 标签上面添加下面的代码进去：

```js
<Head>
    <title>FanMa Blog's HomePage</title>
    <link rel="icon" href="/favicon/favicon.ico" />
</Head>
```

这时候 VS Code 编辑器会出现红色的波浪线提示我们有错误，这时候我们在 `<main>` 和 `<Head>` 外面使用 <> ... </> 来包裹它们就正常了。

这此的 `pages/index.js` 完整的内容如下所示：

```js
import Head from 'next/head';
import Link from 'next/link';

export default function Home() {
  return (
    <>
        <Head>
            <title>FanMa Blog's HomePage</title>
            <link rel="icon" href="/favicon/favicon.ico" />
        </Head>
        <main>
            <h1>
                FanMa Blog's HomePage
            </h1>
            <p>
                This a FanMa Blog.
            </p>
            <ul>
                <li>
                    <Link href="/posts/first-post">My first post.</Link>
                </li>
            </ul>
        </main>
    </>
  );
}
```

回到浏览器 `http://localhost:3000` 的首页，刷新一下网页，此时我们可以看到这个网页在浏览器显示的 `FanMa Blog's HomePage` 标题了。

## 添加网站图标

但是和标题一起添加上去的图标还没有显示出来，别急，接下来我们就把网站图标让它显示出来。

在项目的根目录创建一个 `public` 文件夹，以这个名字命名的文件夹，就是 `next.js` 默认的资产文件夹。然后在 `public` 文件夹下面再建立一个 `favicon` 文件夹，把我们的网站图标 favicon.ico 文件放进 `favicon` 文件夹里就可以了。最后回到浏览器，刷新一下刚才的网页，这时候就能看到网站图标显示在浏览器标题栏里了。

在这里给大家分享一个在线制作网站图标的网站： `https://favicon.io/` ，在这个网站上你可以很轻松地制作精美的网站图标来。它不可以制作 `favicon.ico` 等 `.ico` 格式的图标，还可以制作 `.png` 格式的网站图标。

添加 Head 到 `first-post.js` 文件里。

在 `first-post.js`  文件里还没有 Head 内容信息，现在我们就为它添加上。同样的，也是在文件的顶部，添加下面的代码用来引入 `Head` 组件 `next/head` 。

```js
import Head from 'next/head';
```

然后，在 FirstPost 里面添加输出 Head 的内容信息，并包含 `title` 内容的信息。

```js
export default function FirstPost() {
    return (
        <>
            <Head>
                <title>FanMa's First Post</title>
            </Head>
            <h1>FanMa's First Post</h1>
            <h2>
                <Link href="/">Back to home</Link>
            </h2>
        </>
    );
}
```

回到浏览器中运行 `http://localhost:3000/posts/first-post` 页面，这时我们可以看到这个网页在浏览器上显示的标题为 `FanMa's First Post` 。通过使用浏览器的开发人员工具，您应该会看到标签 `title` 已添加到 `<head>` 标签里了。

## 创建全局布局

创建一个名为 `components` 的文件夹，在这个文件夹里创建一个 `layout.js` 文件，在里面写入下面的代码：

```js
export default function Layout({ children }) {
    return <div>{children}</div>;
}
```

接下来，打开 `pages/posts/first-post.js` 文件，在顶部引入 `Layout` 组件 `../../components/layout `，并使其成为最外层组件：

```js
import Head from 'next/head';
import Link from 'next/link';
import Layout from '../../components/layout';

export default function FirstPost() {
    return (
        <Layout>
            <Head>
                <title>FanMa's First Post</title>
            </Head>
            <h1>FanMa's First Post</h1>
            <h2>
                <Link href="/">Back to home</Link>
            </h2>
        </Layout>
    );
}
```

现在，让我们为Layout组件添加一些样式。为此，我们将使用 `CSS Modules` ，它允许您在 React 组件中导入 CSS 文件。

创建一个名为 `components/layout.module.css` 的文件，并在文件时写入以下内​​容：

```js
.container {
  max-width: 36rem;
  padding: 0 1rem;
  margin: 3rem auto 6rem;
}
```

在要 `components/layout.js` 文件里使用 `.container` 这个类，你还需要完成下面这两步：
- 1、导入 CSS 文件并为其指定一个名称，例如 `styles` 。
- 2、用作styles.container_className 。

打开 `components/layout.js` 文件，并在里面写入下面的代码内容：

```js
import styles from './layout.module.css';

export default function Layout({ children }) {
    return <div className={styles.container}>{children}</div>;
}
```

如果您现在访问 `http://localhost:3000/posts/first-post` 页面，您应该会看到文字在网页中居中的位置。

### 自动生成唯一的类名

现在，如果您查看浏览器开发工具中的 HTML，您会注意到组件div呈现的Layout类名如下所示layout_container__...：

```html
<div id="__next">
    <div class="layout_container__fbLkO">
        <h1>FanMa's First Post</h1>
        <h2><a href="/">Back to home</a></h2>
    </div>
</div>

```

这就是 `CSS Modules` 所做的：它自动生成唯一的类名。只要使用 `CSS Modules` ，就不必担心类名冲突。

此外，Next.js 的代码拆分功能也适用于CSS 模块。它确保为每个页面加载最少数量的 CSS。这导致更小的包大小。

CSS 模块在构建时从 `JavaScript` 包中提取，并生成.css由 Next.js 自动加载的文件。


## 全局样式

 `CSS Modules` 对于组件级样式很有用。但是如果你希望每个页面都加载一些 CSS ，Next.js 也支持。

要将全局 CSS 加载到您的应用程序，请创建一个 `pages/_app.js` 文件并包含以下内容：

```js
export default function App({ Component, pageProps }) {
  return <Component {...pageProps} />;
}
```

默认导出的 `_app.js` 是一个顶级 React 组件，它包装了应用程序中的所有页面。您可以使用此组件设置页面的导航，保持导航在全局可用的状态，或者像我们在这里所做的那样添加全局样式。

重启开发服务器

重要提示：添加 `pages/_app.js` 要重启服务才可以生效， 按 `Ctrl + c` 停止服务器并运行。

```ssh
npm run dev
```

输入上面的命令可以重新启动开发服务器。

### 添加全局 CSS

在 Next.js 中，您可以通过 `pages/_app.js` 导入全局 CSS ， 您不能在其他任何地方导入全局 CSS。

无法在外部导入全局 CSS 的原因是 pages/_app.js 里的全局 CSS 会影响页面上的所有元素。

如果您要从主页导航到该 `/posts/first-post` 页面，主页的全局样式会在 `/posts/first-post` 无任何影响。

您可以将全局 CSS 文件放在任何地方并使用任何名称。因此，让我们执行以下操作：

- 创建一个顶级 `styles` 目录和一个 `global.css` 文件。
- 在 CSS 文件里 styles/global.css 添加下面的内容进去，此代码重置一些样式并更改 `a` 标签的颜色：

```css
html,
body {
  padding: 0;
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu,
    Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
  line-height: 1.6;
  font-size: 18px;
}

* {
  box-sizing: border-box;
}

a {
  color: #0070f3;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

img {
  max-width: 100%;
  display: block;
}

```

最后，将 CSS 文件导入您之前创建的 `pages/_app.js` 文件中：

```js
import '../styles/global.css';

export default function App({ Component, pageProps }) {
    return <Component {...pageProps} />;
}
```

现在，如果您访问 `http://localhost:3000/posts/first-post` ，您会看到样式已应用。在 `_app.js` 里导入的任何样式都将全局应用到应用程序的所有页面。

## 完善布局

到目前为止，我们只添加了最少的 React 和 CSS 代码来说明CSS Modules等概念。在继续学习有关数据获取的下一课之前，让我们完善页面样式和代码。

### 更新 `components/layout.module.css`

首先，打开 `components/layout.module.css` 并将其替换为以下布局：

```js
.container {
  max-width: 36rem;
  padding: 0 1rem;
  margin: 3rem auto 6rem;
}

.header {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.backToHome {
  margin: 3rem 0 0;
}
```

### 创造 `styles/utils.module.css`

其次，让我们创建一组可以跨多个组件重复使用的 CSS 实用程序类（用于文本样式）。

添加一个名为 `styles/utils.module.css` 的 CSS 文件，并写入下面的新内容：

```js
.heading2Xl {
  font-size: 2.5rem;
  line-height: 1.2;
  font-weight: 800;
  letter-spacing: -0.05rem;
  margin: 1rem 0;
}

.headingXl {
  font-size: 2rem;
  line-height: 1.3;
  font-weight: 800;
  letter-spacing: -0.05rem;
  margin: 1rem 0;
}

.headingLg {
  font-size: 1.5rem;
  line-height: 1.4;
  margin: 1rem 0;
}

.headingMd {
  font-size: 1.2rem;
  line-height: 1.5;
}

.borderCircle {
  border-radius: 9999px;
}

.colorInherit {
  color: inherit;
}

.padding1px {
  padding-top: 1px;
}

.list {
  list-style: none;
  padding: 0;
  margin: 0;
}

.listItem {
  margin: 0 0 1.25rem;
}

.lightText {
  color: #666;
}
```

> 您可以在整个应用程序中重复使用这些实用程序类，甚至可以在您的 `global.css` 文件中使用实用程序类。实用类指的是一种编写 CSS 选择器的方法，而不是一种方法（例如全局样式、CSS 模块、Sass 等）。

### 更新 `components/layout.js`

打开 `components/layout.js` 并用以下代码替换其内容，更改 `FanMa` 为您的实际名称：

```js
import Head from 'next/head';
import Image from 'next/image';
import styles from './layout.module.css';
import utilStyles from '../styles/utils.module.css';
import Link from 'next/link';

const name = 'FanMa';
export const siteTitle = 'This a FanMa blog.';

export default function Layout({ children, home }) {
  return (
    <div className={styles.container}>
      <Head>
      <link rel="icon" href="/favicon/favicon.ico" />
        <meta
          name="description"
          content="Welcome to Fanma's blog."
        />
        <meta
          property="og:image"
          content={`https://og-image.vercel.app/${encodeURI(
            siteTitle,
          )}.png?theme=light&md=0&fontSize=75px&images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg`}
        />
        <meta name="og:title" content={siteTitle} />
        <meta name="twitter:card" content="summary_large_image" />
      </Head>
      <header className={styles.header}>
        {home ? (
          <>
          
            <Image
              priority
              src="/images/profile.jpg"
              className={utilStyles.borderCircle}
              height={152}
              width={152}
              alt=""
            />
            <h1 className={utilStyles.heading2Xl}>{name}</h1>
          </>
        ) : (
          <>
            <Link href="/">
              <Image
                priority
                src="/images/profile.jpg"
                className={utilStyles.borderCircle}
                height={108}
                width={108}
                alt=""
              />
            </Link>
            <h2 className={utilStyles.headingLg}>
              <Link href="/" className={utilStyles.colorInherit}>
                {name}
              </Link>
            </h2>
          </>
        )}
      </header>
      <main>{children}</main>
      {!home && (
        <div className={styles.backToHome}>
          <Link href="/">← Back to home</Link>
        </div>
      )}
    </div>
  );
}
```

##### 这是新功能：

- meta 标签（如og:image），用于描述页面内容。
- home 调整标题和图像大小的布尔属性。
- home 如果是，底部的 `← Back to home` 链接关闭。
- 添加了图像 `next/image` 组件，这些图像预加载了priority属性。

### 设置头像

- 1、在你的资产文件夹 public 里创建一个 `images` 文件夹.
- 2、挑选一张帅气漂亮一点的照片做为你的头像，并将你的头像文件名命名为 `profile.jpg` 。
- 3、把头像照片文件 `profile.jpg` 放到刚才创建的 `images` 文件夹里。

### 更新 `pages/index.js`

最后，让我们更新主页内容，打开 `pages/index.js` 并将其内容替换为：

```js
import Head from 'next/head';
import Layout, { siteTitle } from '../components/layout';
import utilStyles from '../styles/utils.module.css';
import Link from 'next/link';

export default function Home() {
  return (
    <Layout home>
        <Head>
            <title>{siteTitle}</title>
        </Head>
        <main className={utilStyles.headingMd}>
            <h1>
                FanMa Blog's HomePage
            </h1>
            <p>
                This a FanMa Blog.
            </p>
            <p>This is a blog site created by FanMa using Next.js. It doesn't have any content yet, which means I will improve it slowly. I'm looking forward to new friends asking about my blog website, I'm really very happy.</p>
            <ul>
                <li>
                    <Link href="/posts/first-post">My first post.</Link>
                </li>
            </ul>
        </main>
    </Layout>
  );
}
```

在浏览器上刷新 `http://localhost:3000` 首页，可以看到您帅气漂亮的头像已经在首页已经显示出来了，在下面还有一些关于您的详细介绍。这就是我们想要的结果，我们的布局代码就已经完善好了。


# 创建一个简单的博客架构

我们示例中的博客文章将作为本地降价文件存储在我们应用程序的目录中（不是从外部数据源获取），因此我们需要从文件系统中读取数据。

在本节中，我们将完成创建一个从文件系统读取降价数据的博客的步骤。

## 创建 .md 文件

首先，在项目根目录创建一个 `posts` 文件夹，在这个文件里创建两个 `.md` 文件。两个名为 `first.md` 、 `about.md` 的文件。

现在，将以下代码复制到 `posts/first.md` 文件里：

```md
---
title: 'FanMa's High-Performance Blog Built with Next.js 13'
date: '2023-01-01'
---

FanMa is a developer who doesn't know JavaScript language, and recently he developed a blog platform using Next.js 13. This platform not only has a beautiful design, but also is very user-friendly.

Next.js 13 is a promising framework that takes React applications to new heights. It provides some useful features, eliminates many common troubles, and produces applications with higher performance and better user experience.

FanMa's blog platform is a good example, and many features of Next.js 13 are applied in this platform.

Firstly, the performance of this platform is excellent. Next.js 13 provides a very fast development environment, allowing developers to create high-performance applications in a short time.

Secondly, this platform is extremely user-friendly. FanMa spent a lot of time designing the interface when developing this platform to ensure that users can use the platform easily and naturally.

Finally, this platform is scalable. FanMa has implemented some very intelligent features to improve the scalability of the platform. For example, he uses some artificial intelligence algorithms to predict with neural networks, so as to automatically generate the best matching tags and improve the searchability of articles.

Overall, FanMa's blog platform is a great example that showcases some of the real advantages of Next.js 13. This platform has excellent performance, is easy to use, and has scalability and many other useful features. We hope to see more developers using Next.js 13 in their applications.
```

```md
---
title: '不懂 JavaScript 语言的 FanMa 使用 Nex.js 开发博客'
date: '2023-01-01'
---

FanMa 是一个不懂 JavaScript 语言的开发者，他最近使用 Next.js 13 开发了一个博客平台。此平台不仅具有美观的设计，而且非常易于使用。

Next.js 13 是一个很有前途的框架，它将 React 应用程序带入到了新的高度。它提供了一些有用的特性，摆脱了很多常见的困扰，并产生了具有更高性能和更好用户体验的应用程序。

FanMa 的博客平台是一个很好的例子，Next.js 13 的许多功能都被应用在这个平台中。

首先，这个平台的性能非常出色。Next.js 13 提供了一个非常快的开发环境，让开发者可以在短时间内创建出高性能的应用程序。

其次，这个平台极其易于使用。FanMa 在开发这个平台的时候花费了大量的时间来设计界面，以确保用户可以简单自然的使用平台。

最后，这个平台具有可扩展性。FanMa 实现了一些非常智能的功能来提高平台的可扩展性。例如，他使用了一些人工智能算法来预测用神经网络，以便自动生成最佳匹配的标签，提高文章的可查找性。

总的来说，FanMa 的博客平台是一个非常棒的例子，展示了 Next.js 13 带来的一些真正的优势。这个平台的性能非常好，易于使用，同时具有可扩展性和许多其他有用的特性。希望我们可以看到更多的开发者在他们的应用程序中使用 Next.js 13。
```

现在，将以下代码复制到 `posts/about.md` 文件里：

```md
---
title: 'About FanMa'
date: '2023-01-01'
---

FanMa is a highly respected developer with a profound understanding and solid experience in programming technology and innovation. His work and achievements have been widely recognized and admired throughout the development community.

FanMa excels at using modern frontend technologies to create excellent web applications, and his high-level skills have gained widespread recognition and praise in this field. He is also committed to sharing his experiences and knowledge with others and participating actively in collaborative work in open-source communities.

FanMa's career began in the early 1990s when he developed a text editor called "FanMa Editor", which provided convenient editing tools for many people. Later, he turned to web development and leveraged his frontend skills to develop a series of outstanding applications and tools.

In addition to his own work and innovation, FanMa actively participates in community work. He has made many contributions to the community in various open-source projects. He is also a dedicated member of several computer technology forums and provides technical help and support to other developers in these forums.

Overall, FanMa is a developer with strong technical abilities and broad creative thinking. His achievements and technical contributions have been widely recognized and praised throughout the web development community, demonstrating his leadership position in this field. We look forward to seeing FanMa continue to demonstrate his talent in the future and bring more innovation and great works to web development.
```

```md
---
title: '关于 FanMa'
date: '2023-01-01'
---

FanMa 是一位备受敬仰的开发者，他对编程技术和创新有着深刻的理解和扎实的经验。他的工作和成就在整个开发社区中备受瞩目。

FanMa 擅长使用现代前端技术来创建优秀的 Web 应用程序，他的高水平技术在这个领域获得了广泛的认可和赞誉。同时，他也致力于将自己的经验和知识分享给开发者们，并在开源社区中积极参与协作工作。

FanMa 的职业生涯始于20世界90年代初期，他早期的成就是开发了一款名为 "FanMa Editor" 的文本编辑器，该编辑器为很多人提供了便捷的编辑器工具。接着，他又转向了 Web 开发，利用自己的前端技术，开发了一系列优秀的应用程序和工具。

除了自己的工作和创新，FanMa 还积极参与社区工作，他在各种开源项目中为社区做出了很多贡献。他也是几个计算机技术论坛的热心成员，并在这些论坛中向其他开发者提供技术帮助和支持。

总的来说，FanMa 是一位技术能力十分强大，创意思维十分开阔的开发者。他的成就和技术贡献得到了整个 Web 开发社区的广泛认可和赞誉，证明了他在这个领域中的领导地位。我们期待着看到 FanMa 在未来继续展现其才华，为 Web 开发带来更多的创新和好作品。
```

您可能已经注意到，每个 `.md` 文件的顶部都有一个元数据部分，其中包含 title 和 date 。这称为 YAML Front Matter，可以使用名为 `gray-matter` 的库对其进行解析。

# 解析 markdown 文件数据

## 安装 gray-matter

首先，安装 `gray-matter` 让我们解析每个 markdown 文件中的元数据。

注意：这一步其实我们在项目一开始就已经做了，这里就不需要再安装 `gray-matter` 了，可以跳过安装 `gray-matter` 这一步。
- 第一篇文章 《 [如何使用 Next.js 构建高效的博客网站](/blog/2023/6.html) 》 里我们在 package.json 文件里添加的内容，就已经有了 `gray-matter` 了。

```ssh
npm install gray-matter
```

### 创建实用函数来读取文件系统

接下来，我们将创建一个实用函数来解析文件系统中的数据。有了这个效用函数，我们想：

- 解析每个降价文件并获取title、date和文件名（将用于id发布 URL）。
- 列出索引页上的数据，按日期排序。
  
lib在根目录中创建一个名为的顶级目录。然后，在 中lib创建一个名为 的文件posts.js，然后复制并粘贴以下代码：

```js
import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';

const postsDirectory = path.join(process.cwd(), 'posts');

export function getSortedPostsData() {
  // Get file names under /posts
  const fileNames = fs.readdirSync(postsDirectory);
  const allPostsData = fileNames.map((fileName) => {
    // Remove ".md" from file name to get id
    const id = fileName.replace(/\.md$/, '');

    // Read markdown file as string
    const fullPath = path.join(postsDirectory, fileName);
    const fileContents = fs.readFileSync(fullPath, 'utf8');

    // Use gray-matter to parse the post metadata section
    const matterResult = matter(fileContents);

    // Combine the data with the id
    return {
      id,
      ...matterResult.data,
    };
  });
  // Sort posts by date
  return allPostsData.sort((a, b) => {
    if (a.date < b.date) {
      return 1;
    } else {
      return -1;
    }
  });
}
```

> ### 笔记：
> 
> 学习Next.js不需要看懂上面的代码是干什么的，作用就是让博客例子功能化。但如果您想了解更多：
> 
> - fs是一个 Node.js 模块，可让您从文件系统中读取文件。
> - path是一个 Node.js 模块，可让您操作文件路径。
> - matter是一个库，可让您解析每个降价文件中的元数据。
> - 在 Next.js 中，lib文件夹没有像pages文件夹那样的指定名称，因此您可以随意命名。通常习惯使用libor utils。

### 获取博客数据

现在已经解析了博客数据，我们需要将它添加到我们的索引页面 ( pages/index.js)。我们可以使用名为 的 Next.js 数据获取方法来完成此操作getStaticProps()。在下一节中，我们将学习如何实现getStaticProps().

# 使用静态生成

## 在 Next.js 中预渲染

Next.js 有两种预渲染形式：Static Generation和Server-side Rendering。区别在于它何时为页面生成 HTML。

- 静态生成是在构建时生成 HTML 的预渲染方法。然后在每个请求上重新使用预呈现的 HTML 。
- 服务器端呈现是在每个请求上生成 HTML 的预呈现方法。

重要的是，Next.js 允许您选择用于每个页面的预呈现表单。您可以通过对大多数页面使用静态生成并为其他页面使用服务器端呈现来创建“混合”Next.js 应用程序。

## 使用静态生成 ( getStaticProps())

现在，我们需要添加一个 import for并在ingetSortedPostsData中调用它。getStaticPropspages/index.js

在您的编辑器中打开pages/index.js并在导出的组件上方添加以下代码Home：

```js
import { getSortedPostsData } from '../lib/posts';

export async function getStaticProps() {
  const allPostsData = getSortedPostsData();
  return {
    props: {
      allPostsData,
    },
  };
}
```

通过返回in 中的对象allPostsData内部，博客文章将作为 prop 传递给组件。现在您可以像这样访问博客文章：propsgetStaticPropsHome

```js
export default function Home ({ allPostsData }) { ... }
```

要显示博客文章，让我们更新组件以在带有您的自我介绍的部分下方Home添加另一个带有数据的标签。<section>不要忘记也将道具从更改()为({ allPostsData })：

```js
export default function Home({ allPostsData }) {
  return (
    <Layout home>
      {/* Keep the existing code here */}

      {/* Add this <section> tag below the existing <section> tag */}
      <section className={`${utilStyles.headingMd} ${utilStyles.padding1px}`}>
        <h2 className={utilStyles.headingLg}>Blog</h2>
        <ul className={utilStyles.list}>
          {allPostsData.map(({ id, date, title }) => (
            <li className={utilStyles.listItem} key={id}>
              {title}
              <br />
              {id}
              <br />
              {date}
            </li>
          ))}
        </ul>
      </section>
    </Layout>
  );
}
```

如果您访问http://localhost:3000 ，您现在应该可以看到博客数据。

恭喜！我们已经成功地获取了外部数据（从文件系统）并使用这些数据预渲染了索引页面。



# 使用动态路由创建静态博客页面

## 引言

我们已经将博客数据填充到索引页面中，但我们还没有创建单独的博客页面。我们希望这些页面的 URL 获取博客数据，这意味着我们需要使用动态路由。

在本课程中，您将学习：

- 如何使用 getStaticPaths 静态生成具有动态路由的页面。
- 如何编写 getStaticProps 来获取每篇博客文章的数据。
- 如何使用 remark 渲染 markdown。
- 如何漂亮地打印日期字符串。
- 如何链接到具有动态路由的页面。
- 关于动态路由的一些有用信息。


## 页面路径获取外部数据

在上一个课程中，我们讨论了页面内容获取外部数据的情况。我们使用getStaticProps获取所需数据来渲染索引页面。

在本课程中，我们将讨论每个页面路径获取外部数据的情况。Next.js允许您静态生成具有依赖于外部数据的路径的页面。这使得Next.js中的动态URL成为可能。

## 如何使用动态路由静态生成页面

在我们的情况下，我们想要为博客文章创建动态路由：

我们希望每篇文章的路径为 `/posts/` ，其中是顶级 posts 目录下的 markdown 文件名。 由于我们有 `first.md` 和 `about.md` ，我们希望路径为 `/posts/first` 和 `/posts/about` 。 步骤概览 我们可以通过执行以下步骤来实现。您现在不必进行这些更改 - 我们将在下一页上完成全部。

首先，我们将在 `pages/posts` 下创建名为 `[id].js` 的页面。以 `[` 开头并以 `]` 结尾的页面是 `Next.js` 中的动态路由。

在 `pages/posts/[id].js` 中，我们将编写代码，该代码将呈现一个帖子页面，就像我们创建的其他页面一样。

```js
import Layout from '../../components/layout';

export default function Post() {
  return <Layout>...</Layout>;
}
```

现在有新内容：我们将从此页面导出一个名为 `getStaticPaths` 的异步函数。在此函数中，我们需要返回id的可能值列表。

```js
import Layout from '../../components/layout';

export default function Post() {
  return <Layout>...</Layout>;
}

export async function getStaticPaths() {
  // Return a list of possible value for id
}
```

最后，我们需要重新实现 `getStaticProps` - 这次是为了获取给定id的博客文章所需的数据。 `getStaticProps` 被赋予 `params` ，其中包含id（因为文件名是 `[id].js` ）。

```js
import Layout from '../../components/layout';

export default function Post() {
  return <Layout>...</Layout>;
}

export async function getStaticPaths() {
  // Return a list of possible value for id
}

export async function getStaticProps({ params }) {
  // Fetch necessary data for the blog post using params.id
}
```
让我们在下一篇文章进行尝试！



## 动态路由实现 getStaticPaths 

首先，让我们设置文件：

- 在 `pages/posts` 目录中创建一个名为 `[id] .js` 的文件。
- 另外，删除 `pages/posts` 目录中的 `first-post.js` - 我们将不再使用此文件。
- 然后，打开编辑器中的 `pages/posts/[id].js` 并粘贴以下代码。稍后我们将填写...：

```js
import Layout from '../../components/layout';

export default function Post() {
  return <Layout>...</Layout>;
}
```

然后，打开 `lib/posts.js` 并在底部添加以下 `getAllPostIds` 函数。它将返回帖子目录中文件名（不包括.md）的列表：

```js
export function getAllPostIds() {
  const fileNames = fs.readdirSync(postsDirectory);

  // Returns an array that looks like this:
  // [
  //   {
  //     params: {
  //       id: 'ssg-ssr'
  //     }
  //   },
  //   {
  //     params: {
  //       id: 'pre-rendering'
  //     }
  //   }
  // ]
  return fileNames.map((fileName) => {
    return {
      params: {
        id: fileName.replace(/\.md$/, ''),
      },
    };
  });
}
```

重要提示：返回的列表不仅仅是字符串数组-它必须是像上面的注释所示的对象数组。每个对象必须具有 `params` 键，并包含一个带有id键的对象（因为我们在文件名中使用[id]）。否则，` getStaticPaths` 将失败。

最后，我们将导入 `getAllPostIds` 函数并在 `getStaticPaths` 中使用它。打开 `pages/posts/[id].js` 并将以下代码复制到导出的Post组件上方：

```js
import { getAllPostIds } from '../../lib/posts';

export async function getStaticPaths() {
  const paths = getAllPostIds();
  return {
    paths,
    fallback: false,
  };
}
```

- 路径包含由 `getAllPostIds（）` 返回的已知路径数组，其中包括由 `pages/posts/[id].js` 定义的参数。
- 了解有关路径键文档的更多信息 暂时忽略 `fallback：false` -稍后我们将解释这个内容。

我们快完成了-但我们仍需要实现 `getStaticProps` 。让我们在下一页中做到这一点！


# 获取文章信息

## 设置 getStaticProps

我们需要获取必要的数据来渲染给定 id 的文章。

为此，再次打开 `lib/posts.js` 并在底部添加以下 `getPostData` 函数。它将根据id返回文章数据：

```js
export function getPostData(id) {
  const fullPath = path.join(postsDirectory, `${id}.md`);
  const fileContents = fs.readFileSync(fullPath, 'utf8');

  // Use gray-matter to parse the post metadata section
  const matterResult = matter(fileContents);

  // Combine the data with the id
  return {
    id,
    ...matterResult.data,
  };
}
```

然后，打开页面 `/posts/[id].js` 并将此行：

```js
import { getAllPostIds } from '../../lib/posts';
```

替换为以下代码：

```js
import { getAllPostIds, getPostData } from '../../lib/posts';

export async function getStaticProps({ params }) {
  const postData = getPostData(params.id);
  return {
    props: {
      postData,
    },
  };
}
```

文章页面正在使用 `getPostData` 函数在 `getStaticProps` 中获取文章数据并将其作为 `props` 返回。

现在，让我们更新 `Post` 组件以使用 `postData` 。在页面 `/posts/[id].js` 中，用以下代码替换导出的 `Post` 组件：

```jsx
export default function Post({ postData }) {
  return (
    <Layout>
      {postData.title}
      <br />
      {postData.id}
      <br />
      {postData.date}
    </Layout>
  );
}
```

完成了！尝试访问这些页面：

http://localhost:3000/posts/first
http://localhost:3000/posts/about

现在，您应该能够看到每个页面的博客数据.

太好了！我们已成功生成动态路由。

我们仍然没有显示博客 `Markdown` 内容，下一篇文章主要给大家讲显示博客 `Markdown` 内容。

# 读取 Markdown 内容数据

## 渲染 Markdown

为了渲染 `Markdown` 内容，我们将使用 `remark` 库。首先，让我们安装它：

注意：这一步其实我们在项目一开始就已经做了，这里就不需要再安装 `remark` 库了，可以跳过安装 `remark` 这一步。
- 第一篇文章 《 [如何使用 Next.js 构建高效的博客网站](/blog/2023/6.html) 》 里我们在 package.json 文件里添加的内容，就已经有 `remark` 了。

```ssh
npm install remark remark-html
```
然后，打开 `lib/posts.js` ，并在文件顶部添加以下导入：

```js
import { remark } from 'remark';
import html from 'remark-html';
```

并在同一文件中更新 `getPostData()` 函数以使用 `remark` ：

```js
export async function getPostData(id) {
  const fullPath = path.join(postsDirectory, `${id}.md`);
  const fileContents = fs.readFileSync(fullPath, 'utf8');

  // Use gray-matter to parse the post metadata section
  const matterResult = matter(fileContents);

  // Use remark to convert markdown into HTML string
  const processedContent = await remark()
    .use(html)
    .process(matterResult.content);
  const contentHtml = processedContent.toString();

  // Combine the data with the id and contentHtml
  return {
    id,
    contentHtml,
    ...matterResult.data,
  };
}
```

重要提示：我们在 `getPostData` 中添加了 `async` 关键字，因为我们需要使用 `await` 来调用 `remark` 。 `async/await` 允许您异步获取数据。

这意味着我们需要更新 `pages/posts/[id].js` 中的 `getStaticProps` ，在调用 `getPostData` 时使用 `await` ：

```js
export async function getStaticProps({ params }) {
  // Add the "await" keyword like this:
  const postData = await getPostData(params.id);

  return {
    props: {
      postData,
    },
  };
}
```

最后，在 `pages/posts/[id].js` 中更新 `Post` 组件，以使用 `dangerouslySetInnerHTML` 呈现 `contentHtml` 里的内容：

```js
export default function Post({ postData }) {
  return (
    <Layout>
      {postData.title}
      <br />
      {postData.id}
      <br />
      {postData.date}
      <br />
      <div dangerouslySetInnerHTML={{ __html: postData.contentHtml }} />
    </Layout>
  );
}
```

尝试再次访问这些页面：

http://localhost:3000/posts/first
http://localhost:3000/posts/about

您现在应该看到博客内容了：

我们快完成了！下一篇文章我们将优化每个页面。

# 完善文章页面

## 添加文章页面的标题

在 `pages/posts/[id].js` 文件中，让我们使用文章数据添加 `title` 标签。您需要在文件顶部添加 `next/head` 的 `import` ，并通过更新 `Post` 组件添加 `title` 标签：

```js
import Head from 'next/head';

export default function Post({ postData }) {
  return (
    <Layout>
      {/* Add this <Head> tag */}
      <Head>
        <title>{postData.title}</title>
      </Head>

      {/* Keep the existing code here */}
    </Layout>
  );
}
```

## 格式化日期

要格式化日期，我们将使用 `date-fns` 库。首先，安装它：

注意：这一步其实我们在项目一开始就已经做了，这里就不需要再安装 `date-fns` 库了，可以跳过安装 `date-fns` 这一步。
- 第一篇文章 《 [如何使用 Next.js 构建高效的博客网站](/blog/2023/6.html) 》 里我们在 package.json 文件里添加的内容，就已经有 `date-fns` 了。

```js
npm install date-fns
```

接下来，创建一个叫做 `components/date.js` 的文件，并添加以下日期组件：

```js
import { parseISO, format } from 'date-fns';

export default function Date({ dateString }) {
  const date = parseISO(dateString);
  return <time dateTime={dateString}>{format(date, 'LLLL d, yyyy')}</time>;
}
```

注意：您可以在 [date-fns](https://date-fns.org/v2.16.1/docs/format) 网站上查看不同的格式()字符串选项。

现在，打开 `pages/posts/[id].js` ，添加一个 `Date` 组件的导入，在 `{postData.date}` 上使用它：

```js
// Add this import
import Date from '../../components/date';

export default function Post({ postData }) {
  return (
    <Layout>
      {/* Keep the existing code here */}

      {/* Replace {postData.date} with this */}
      <Date dateString={postData.date} />

      {/* Keep the existing code here */}
    </Layout>
  );
}
```

如果您访问 `http://localhost:3000/posts/pre-rendering` ，则现在应该看到日期已写为 `January 1, 2023` 。

添加CSS

最后，让我们使用我们之前添加的 `styles/utils.module.css` 文件添加一些CSS。打开 `pages/posts/[id].js` ，然后添加CSS文件的导入，并将 `Post` 组件替换为以下代码：

```js
import utilStyles from '../../styles/utils.module.css';

export default function Post({ postData }) {
  return (
    <Layout>
      <Head>
        <title>{postData.title}</title>
      </Head>
      <article>
        <h1 className={utilStyles.headingXl}>{postData.title}</h1>
        <div className={utilStyles.lightText}>
          <Date dateString={postData.date} />
        </div>
        <div dangerouslySetInnerHTML={{ __html: postData.contentHtml }} />
      </article>
    </Layout>
  );
}
```

如果您访问 `http://localhost:3000/posts/pre-rendering` ，则页面现在应该看起来更好：

干得好！接下来我们将完善索引页面，然后就完成啦！

# 优化索引页面

接下来，让我们更新我们的索引页面 `pages/index.js` 。我们需要使用 `Link` 组件添加到每篇文章页面的链接。

打开 `pages/index.js` ，并在文件顶部添加以下 `Link` 和 `Date` 的引入：

```js
import Link from 'next/link';
import Date from '../components/date';
```

然后，在 `Home` 组件的底部，用以下代码替换 `li` 标签：

```js
<li className={utilStyles.listItem} key={id}>
  <Link href={`/posts/${id}`}>{title}</Link>
  <br />
  <small className={utilStyles.lightText}>
    <Date dateString={date} />
  </small>
</li>
```

如果您现在访问 `http://localhost:3000` 页面，就可以看到页面中每篇文章都有链接了。

就这样，一个简单的博客网站就做好了。

如果有什么不对劲，请确保你的代码是正确没问题的，你可以参考本站 《 使用 Next.js 构建高效的博客网站 》 教程在 GitHub 源码库里的代码。

GitHub 源码库：https://github.com/fanmau/next-fanmau

就这样，我们使用 Next.js 构建高效的博客网站教程就已经完成了。现在就可以把我们的博客网站部署到网络空间上面去了，在这里 FanMa 推荐 《 [使用 Next.js 自动将应用部署到 GitHub Pages](https://fanmau.github.io/blog/2023/5.html) 》。

使用 `GitHub Pages` 自动部署，可以很方便快捷地把你的网站自动部署到网络空间上面去。只要把文章写好，直接使用 git 推送到 `GitHub Pages` 它就会帮您自动打包构建博客网站，此操作不需要在本地进行任何打包构建操作。

```js

```


```js

```


```js

```


```js

```


```js

```


```js

```


```js

```


```js

```