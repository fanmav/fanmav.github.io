# 如果 .md 文件里有链接 就在链接里添加 target="_blank"

您可以在remark插件中使用remark-external-links插件，它将自动将外部链接添加到target='_blank'和rel='nofollow'属性。

首先要安装该插件，在命令行中运行：npm install remark-external-links

然后，导入模块并将其添加到您的remark插件列表中：

```ts
import remarkExternalLinks from 'remark-external-links'

async function getPostData(slug:any) {
  //...
  const processedContent = await remark()
    .use(html, { sanitize: false })
    .use(remarkPrism, { plugins: ["line-numbers"] })
    .use(remarkExternalLinks) // add this line
    .process(matterResult.content)
  //...
}
```
现在，所有外部链接都将自动添加到target='_blank'和rel='nofollow'属性中。

# rel='nofollow'是什么意思

链接里的 `rel='nofollow'` 是HTML中的一种rel属性，用于告诉搜索引擎不要传递PageRank到链接的目标网页。PageRank是Google搜索引擎页面排序算法的核心部分，传递PageRank是指搜索引擎使用一个网站对外链的情况来判断该网站的权重。使用 `rel='nofollow'` 可以防止被外链的网站滥用权重，也可以防止您网站上的恶意链接污染整个站点的信誉度。所以， `rel='nofollow'` 广泛应用于包含用户生成内容的网站，如博客评论，论坛帖子等。

# 我不想添加 rel='nofollow'

如果您不想添加rel='nofollow'，则可以省略添加remark-external-links插件，并手动处理<a>标签，如下所示：

```ts
const processedContent = await remark()
  .use(html, { sanitize: false })
  .use(remarkPrism, { plugins: ["line-numbers"] })
  .use(() => {
    return (tree: any) => {
      visit(tree, 'link', (node: any) => {
        // check if link is external
        if (node.url.startsWith('http')) {
          // add target='_blank' attribute
          node.properties.target = '_blank'
        }
      })
    }
  })
  .process(matterResult.content)

```

这个例子使用remark中的visit方法对树进行遍历。处理过程中，对于每个link节点，检查它是否是外部链接（url以HTTP或HTTPS开头）。如果是，就添加target='_blank'属性，这将使链接在新窗口或选项卡中打开。

# 如果文章没有标题，就用 .md 文件里的第一个 h1 作为文件标题

您可以使用 `remark`和`unified` 库来解析 `markdown` 文件中的标题和内容。对于缺少标题的文章，您可以使用文章内容中第一个h1标签的文本作为文章标题。下面是一个示例函数实现：

```ts
import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';
import remark from 'remark';
import html from 'remark-html';
import unified from 'unified';
import parse from 'remark-parse';

async function getPostData(slug:any) {
  const aPath = path.join(process.cwd(), 'blog')
  const idjoin = slug.toString().split(",").join("//").replace(/\.html$/, '')
  const id = path.join(idjoin);
  const fullPath = path.join(aPath, `${id}.md`);
  const fileContents = fs.readFileSync(fullPath, 'utf8');
  const chineseChars = fileContents.match(/[\u4e00-\u9fa5]/g);

  // 统计中文字符数
  const chineseCount = fileContents.match(/[\u4e00-\u9fa5]/g).length;

  // 统计英文单词数
  const englishCount = fileContents.match(/[a-zA-Z]+/g).length;

  const wordCount = chineseCount + englishCount;

  // Parse the markdown content using remark and unified
  const { content, data: frontmatter } = matter(fileContents);
  const contentHtml = await unified().use(parse).use(html).process(content);

  let title = frontmatter.title;
  if (!title) {
    // find the first h1 tag in the content and use its text as the title
    const match = content.match(/<h1.*?>(.*?)<\/h1>/);
    title = match ? match[1] : '';
  }

  // strip all html tags from the title string
  title = title.replace(/<.*?>/g, '');

  // Add target='_blank' to all external links
  const processedContent = await remark()
    .use(html, { sanitize: false })
    .use(linkTarget)
    .process(content);

  return {
    slug,
    title,
    wordCount,
    contentHtml,
    ...frontmatter
  };
}

// Add target='_blank' to all external links
function linkTarget() {
  return (tree: any) => {
    for (const node of tree.children) {
      if (node.tagName === 'a' && node.properties.href.startsWith('http')) {
        node.properties.target = '_blank';
      }
    }
  };
}
```

此示例使用 `matter` 将` markdown `文件解析为前置 `Matter` 数据和内容。如果有 `title` 字段，则将其用作文章标题，否则将找到内容中第一个h1标签并使用其文本作为标题。最后，将处理后的内容字符串传递给 `remark` ，以便添加 `target='_blank'` 属性到所有外部链接的<a>标签。

# 按文件夹分类自动生成侧边栏

下面是一个按目录分类自动生成侧边栏的示例函数实现，它会返回一个对象，其中的键是文件夹名称，值是包含文件夹内所有文章信息的数组（包括标题，路径和日期）。

```ts
import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';

async function getSideBarData() {
  const postsDirectory = path.join(process.cwd(), 'blog');
  const directories = fs.readdirSync(postsDirectory, { withFileTypes: true })
    .filter(dirent => dirent.isDirectory())
    .map(dirent => dirent.name);

  const allPostsData = {};

  for (const directory of directories) {
    const directoryPath = path.join(postsDirectory, directory);
    const fileNames = fs.readdirSync(directoryPath);
    const postsData = [];

    for (const fileName of fileNames) {
      const id = fileName.replace(/\.md$/, '');
      const fullPath = path.join(directoryPath, fileName);
      const fileContents = fs.readFileSync(fullPath, 'utf8');
      const matterResult = matter(fileContents);
      postsData.push({
        slug: `${directory}/${id}`,
        title: matterResult.data.title,
        date: matterResult.data.date
      });
    }

    // sort posts by date in descending order
    postsData.sort((a, b) => {
      if (a.date < b.date) {
        return 1;
      } else {
        return -1;
      }
    });

    allPostsData[directory] = postsData;
  }

  return allPostsData;
}
```

此函数会读取所有 markdown 文件，先按目录过滤出所有的文件夹名称，然后对每个文件夹内的所有文件进行解析，并将文章信息组织成一个对象，其中的键是文件夹名称，值是包含文件夹内所有文章信息的数组（包括标题，路径和日期）。最后，按每篇文章的日期进行排序，并将其返回以供在页面上循环渲染。

您可以将其与您的网站模板一起使用，例如，在 `Next.js` 和 `Nuxt.js` 中，您可以将此函数放在可重用的mixin中，并在多个组件中使用它来为不同的侧边栏生成数据。

# 在 Next.js 中使用 Typescript 和按目录分类自动生成的侧边栏

下面是一个在 Next.js 中使用 Typescript 和按目录分类自动生成的侧边栏的示例：

```ts
import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';

export interface PostData {
  slug: string;
  title: string;
  date: string;
}

export interface SideBarData {
  [key: string]: PostData[];
}

export async function getSideBarData(): Promise<SideBarData> {
  const postsDirectory = path.join(process.cwd(), 'blog');
  const directories = fs.readdirSync(postsDirectory, {
    withFileTypes: true
  }).filter(dirent => dirent.isDirectory()).map(dirent => dirent.name);

  const allPostsData: SideBarData = {};

  for (const directory of directories) {
    const directoryPath = path.join(postsDirectory, directory);
    const fileNames = fs.readdirSync(directoryPath);
    const postsData: PostData[] = [];

    for (const fileName of fileNames) {
      const id = fileName.replace(/\.md$/, '');
      const fullPath = path.join(directoryPath, fileName);
      const fileContents = fs.readFileSync(fullPath, 'utf8');
      const matterResult = matter(fileContents);
      postsData.push({
        slug: `${directory}/${id}`,
        title: matterResult.data.title,
        date: matterResult.data.date
      });
    }

    // sort posts by date in descending order
    postsData.sort((a, b) => {
      if (a.date < b.date) {
        return 1;
      } else {
        return -1;
      }
    });

    allPostsData[directory] = postsData;
  }

  return allPostsData;
}
```
此示例导出了两个接口`Post

# 在 Next.js 中使用 Typescript 和按目录分类自动生成的侧边栏

当使用 Next.js 时，你可以同时使用 TypeScript 和自动生成的侧边栏，来构建你的应用程序。以下是一些可帮助你完成的步骤：

- 首先，确保你的项目中已安装并正确配置了 TypeScript 和 Next.js。可以运行以下命令来安装它们：
  
```ssh
npm install --save-dev typescript @types/react @types/node
```

- 接下来，你需要创建一个tsconfig.json文件，用于配置 TypeScript 编译器。在项目的根目录中创建此文件，并添加以下内容：

```json
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve"
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}
```
此文件配置了 TypeScript 编译器，并告诉它要编译哪些文件。

- 接下来，你需要安装和配置自动生成的侧边栏。你可以使用 Docusaurus 来自动生成侧边栏和文档站点。运行以下命令安装 Docusaurus：

```ssh
npm install --save-dev docusaurus
```
- 接下来，你需要在项目的根目录中创建一个名为docs的文件夹。在docs文件夹中，你可以创建一个目录结构，其中包含你的文档。每个文档应该是一个名为*.md的 Markdown 文件。例如：

```
docs/
  intro/
    index.md
  setup/
    index.md
```

在每个 Markdown 文件的顶部，你需要添加一些元数据，以便 Docusaurus 可以自动生成侧边栏。以下是示例元数据：

在这个元数据中，id是该文档的唯一标识符，title是在侧边栏和页面标题中显示的文本，sidebar_label是在侧边栏中显示的文本。你需要对每个文档都添加类似的元数据。

- 当你完成文档和元数据的设置后，你需要在 Next.js 应用程序中添加 Docusaurus。你可以使用以下代码：

```js
import { MDXProvider } from '@mdx-js/react';
import MDXComponents from '../components/MDXComponents';
import Layout from '../components/Layout';
import Sidebar from '../components/Sidebar';
import { getAllDocs } from '../lib/docs';

export default function Home({ docs }) {
  return (
    <MDXProvider components={MDXComponents}>
      <Layout>
        <Sidebar docs={docs} />
        <main>
          <h1>Welcome to my documentation site!</h1>
        </main>
      </Layout>
    </MDXProvider>
  );
}

export async function getStaticProps() {
  const docs = await getAllDocs();
  return {
    props: { docs },
  };
}
```

这里，getAllDocs()是一个函数，它将遍历docs目录并返回所有文档的元数据。你可以根据自己的需求编写这个函数，并传递相关的数据到Sidebar组件中。同时，你需要使用MDXProvider组件来渲染 Markdown 文件。在这个组件中，你可以使用MDXComponents对象来自定义渲染 Markdown 的元素。例如：

```js
const MDXComponents = {
  h1: (props) => <h1 style={{ color: 'tomato' }} {...props} />,
};
```

这将会更改所有渲染h1标记的元素的颜色为番茄色。

通过执行以上步骤，你就可以在 Next.js 应用程序中同时使用 TypeScript 和自动生成的侧边栏了。

# Next.js /blog/[...slug].tsx  路径 /blog/2023/1.html 生成 /blog/2023/1.html 
# 我想使用 路径  /blog/2023/1.html ，生成路径也是 /blog/2023/1.html 

# 但是这样生成的路径就成了 /blog/2023/1.html.html  路径中多了一个.html

# 我想要 URL 是  /blog/2023/1.html ，生成静态 HTML 也是 /blog/2023/1.html 

# 但是这样在服务端渲染就访问不了 /blog/2023/1.html ，只能访问 /blog/2023/1

是的，因为服务端渲染使用的是文件系统路径，而文件系统路径是没有后缀的。

如果您需要在服务端渲染中使用含有后缀的url，可以采用如下两种方法。

方法一：使用next.js内置的slug模块对url进行处理。

安装 slug 模块：

```ssh
npm install @types/slug slug
```
在getAllPostIds中使用slug模块处理slug：

```ts
import slugify from 'slug'

export function getAllPostIds() {
  const fileNames = fs.readdirSync(postsDirectory)
  return fileNames.map(fileName => {
    const slug = fileName.slice(0, -3);
    return {
      params: {
        slug: slugify(slug, { lower: true }) + '.html', // add .html back
      }
    }
  })
}
```


```ts
export function getAllPostIds() {

    const Directory = path.join(process.cwd(), 'blog')
    const subdirectories = fs.readdirSync(Directory, { withFileTypes: true })
      .filter(dirent => dirent.isDirectory())
      .map(dirent => dirent.name)
  
    const paths = subdirectories.flatMap(subdirectory => {
      const directoryPath = path.join(Directory, subdirectory)
      const filenames = fs.readdirSync(directoryPath)
        .filter(filename => filename.endsWith('.md'))

        return filenames.map(filename => {
          const slug = [subdirectory, filename.replace(/\.md$/, '')];
          const slugPath = slug.join('/');
          const formattedSlug = slugify(slugPath, { lower: true, replacement: '/', remove: null });
          return {
            params: {
              slug: formattedSlug + '.html'
            }
          }
        })  
  
      // return filenames.map(filename => ({
      //   params: {
      //     slug: [subdirectory, filename.replace(/\.md$/, '')]
      //   }
      // }))
    })
    console.log(paths)
    return paths
}

这里是 /lib/blog.ts 里的代码

export const getStaticPaths: GetStaticPaths = async () => {
  const paths = getAllPostIds()
  

  return {
    paths,
    fallback: false
  }
}

在 [...slug].tsx 引用出错

错误信息为 Error: A required parameter (slug) was not provided as an array in getStaticPaths for /blog/[...slug]

/lib/blog.ts 里使用了 slugify ，在 /lib/blog.ts 可以正常打印，到 [...slug].tsx 里就引用出错了

```

# Next.js ts  HTML静态文件输出 out/blog/2023/1.html.html ，文件多了一个.html 

# Next.js 13 要怎么设置 [...slug].tsx 构建输出路径和文件名的选项

# 使用 npm run build 时 这里 fanma/another/path/1.html.html 文件名多了一个后缀 .html 

# 访问 /fanma/another/path/1.html 为404 ，访问 /fanma/another/path/1 正确解析

# 使用 Next.js 13 [...slug].tsx 这里生成静态页的时候 多了一个扩展名 .html 

# 使用 Next.js 13 [...slug].tsx build 时如何设置 某个参数 为生成HTML静态文件的文件名

```ts
    const content = 'This is the content of the page'
  
    const fullPath = path.join(process.cwd(), 'out', `${filePath}.html`)
    fs.mkdirSync(path.dirname(fullPath.slice(0, -5)), { recursive: true })
    fs.writeFileSync(fullPath.slice(0, -5), content)
  
```
# 我想要删除 out/blog/ 文件夹里 .html.html 其中一个文件扩展名 只保留一个文件扩展名就行了

# 把 /blog/1 的路径改为 /blog/page-1.html 写完整的代码

/pages/blog/[page].tsx 路径配置为 params: { page: 'index.html' } ，访问 /blog/ 为404
/pages/blog/index.tsx 添加 index.tsx  文件可以正常访问 /blog/

# Next.js 13 [page].tsx 帮我把 /blog/ 设置成索引页